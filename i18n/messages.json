{
	"pathLogic" : "Logic",

	"nameTrue"    : "The logical true value",
	"literalTrue" : "true",
	"leafTrue"    : "true",

	"nameFalse"    : "The logical false value",
	"literalFalse" : "false",
	"leafFalse"    : "false",

	"nameNegation"     : "Logical negation",
	"literalNegation"  : "¬",
	"mnemonicNegation" : "not",
	"leafNegation"     : "Negation (not)",

	"nameConjunction"     : "Logical conjunction",
	"operatorConjunction" : "∧",
	"mnemonicConjunction" : "and",
	"leafConjunction"     : "Conjunction (and)",

	"nameDisjunction"     : "Logical disjunction",
	"operatorDisjunction" : "∨",
	"mnemonicDisjunction" : "or",
	"leafDisjunction"     : "Disjunction (or)",

	"nameImplication"     : "Logical implication",
	"operatorImplication" : "⟶",
	"mnemonicImplication" : "implies",
	"leafImplication"     : "Implication (if)",

	"nameEquivalence"     : "Logical equivalence",
	"operatorEquivalence" : "⟺",
	"mnemonicEquivalence" : "equivalent",
	"leafEquivalence"     : "Equivalence (if and only if)",

	"nameExclusiveDisjunction"     : "Logical exclusive disjunction",
	"operatorExclusiveDisjunction" : "⊕",
	"mnemonicExclusiveDisjunction" : "xor",
	"leafExclusiveDisjunction"     : "Exclusive disjunction (xor)",
	
	"pathBigConjunction"          : "Logic.∧ Big conjunction",
	"pathBigDisjunction"          : "Logic.∨ Big disjunction",
	"pathBigEquivalence"          : "Logic.⇔ Big equivalence",
	"pathBigExclusiveDisjunction" : "Logic.⊕ Big exclusive disjunction",
	
	"nameBigConjunction"          : "Big conjunction",
	"nameBigDisjunction"          : "Big disjunction",
	"nameBigEquivalence"          : "Big equivalence",
	"nameBigExclusiveDisjunction" : "Big exclusive disjunction",
	
	"childBigConjunction0"           : "Expression to be used to create the big conjunction",
	"childBigDisjunction0"           : "Expression to be used to create the big disjunction",
	"childBigEquivalence0"           : "Expression to be used to create the big equivalence",
	"childBigExclusiveDisjuncation0" : "Expression to be used to create the big exclusive disjunction",
	"childBig1"                      : "Symbol to be used over the iteration",
	"childBig23"                     : "List containing the elements to be iterated over",
	"childBig2X"                     : "Starting value of iteration",
	"childBig3"                      : "Ending value of iteration",
	"childBig4"                      : "Step of the iteration",
	
	"namePredicate"   : "Predicate",
	"leafPredicate0"  : "Predicate",
	"leafPredicateN"  : "Predicate(...)",
	"enterPredicate"  : "Enter predicate name",
	"updatePredicate" : "Update predicate name",
	"actionPredicate" : "Edit predicate name...",

	"pathFirstOrder" : "Logic.First order",

	"mnemonicForAll" : "∀",
	"nameForAll"     : "Universal quantification",
	"leafForAll"     : "∀",

	"mnemonicExists" : "∃",
	"nameExists"     : "Existencial quantification",
	"leafExists"     : "∃"
}

